<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Enhanced Multi-Agent Simulation with Dynamic Attention and Q-Learning</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body { font-family: Arial, sans-serif; margin: 0; background-color: #f0f2f5; overflow: hidden; }
        #controls {
            position: absolute; top: 10px; right: 10px; color: white; background: rgba(0, 0, 0, 0.7); padding: 10px; border-radius: 5px;
        }
        #controls label { display: block; margin-top: 10px; }
    </style>
</head>
<body>
<div id="controls">
    <h3>Simulation Controls</h3>
    <label>Agent Speed: <input type="range" id="agentSpeed" min="0.5" max="5" step="0.1" value="2"></label>
    <label>Attention Scaling: <input type="range" id="attentionScale" min="0.1" max="2" step="0.1" value="1"></label>
    <button id="resetSimulation">Reset Simulation</button>
</div>

<script>
    let scene, camera, renderer, agents = [], obstacles = [], threats = [], energySources = [];
    let agentSpeed = 2, attentionScale = 1;

    // Initialize Three.js Scene
    function initScene() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 50);
        renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
    }

    class QLearningAgent {
        constructor(id, speed) {
            this.id = id;
            this.speed = speed;
            this.position = new THREE.Vector3(Math.random() * 40 - 20, Math.random() * 40 - 20, 0);
            this.direction = new THREE.Vector3(Math.random() - 0.5, Math.random() - 0.5, 0).normalize();
            this.dynamicAttentionScale = attentionScale;
            this.energy = 100;
            this.qTable = {}; // Placeholder for Q-learning table

            // Visual Representation
            this.mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0x00ff00 })
            );
            scene.add(this.mesh);
        }

        senseEnvironment() {
            let closestThreat = null, closestEnergySource = null;
            let minThreatDist = Infinity, minEnergyDist = Infinity;

            for (let threat of threats) {
                const distance = this.position.distanceTo(threat.position);
                if (distance < minThreatDist) {
                    minThreatDist = distance;
                    closestThreat = threat;
                }
            }

            for (let energy of energySources) {
                const distance = this.position.distanceTo(energy.position);
                if (distance < minEnergyDist) {
                    minEnergyDist = distance;
                    closestEnergySource = energy;
                }
            }

            return { closestThreat, minThreatDist, closestEnergySource, minEnergyDist };
        }

        updatePosition() {
            const { closestThreat, minThreatDist, closestEnergySource, minEnergyDist } = this.senseEnvironment();

            // Avoid threats if close
            if (closestThreat && minThreatDist < 5 * this.dynamicAttentionScale) {
                this.direction.add(new THREE.Vector3(
                    this.position.x - closestThreat.position.x,
                    this.position.y - closestThreat.position.y,
                    0
                ).normalize());
            }

            // Move towards energy source if low on energy
            if (this.energy < 50 && closestEnergySource && minEnergyDist < 20 * this.dynamicAttentionScale) {
                this.direction.add(new THREE.Vector3(
                    closestEnergySource.position.x - this.position.x,
                    closestEnergySource.position.y - this.position.y,
                    0
                ).normalize());
            }

            // Move and update energy
            this.position.add(this.direction.clone().multiplyScalar(this.speed));
            this.mesh.position.copy(this.position);
            this.energy -= 0.05 * this.speed;

            this.checkEnergyReplenishment();
            this.checkThreatCollision();
            this.stayInBounds();
        }

        checkEnergyReplenishment() {
            for (let i = energySources.length - 1; i >= 0; i--) {
                if (this.position.distanceTo(energySources[i].position) < 1) {
                    this.energy = Math.min(100, this.energy + 50);
                    scene.remove(energySources[i].mesh);
                    energySources.splice(i, 1);
                    addEnergySource();
                }
            }
        }

        checkThreatCollision() {
            for (let threat of threats) {
                if (this.position.distanceTo(threat.position) < 1) {
                    this.energy = 0;
                    this.position.set(Math.random() * 40 - 20, Math.random() * 40 - 20, 0);
                }
            }
        }

        stayInBounds() {
            if (this.position.x < -40 || this.position.x > 40) this.direction.x *= -1;
            if (this.position.y < -40 || this.position.y > 40) this.direction.y *= -1;
        }
    }

    class Threat {
        constructor() {
            this.position = new THREE.Vector3(Math.random() * 80 - 40, Math.random() * 80 - 40, 0);
            this.mesh = new THREE.Mesh(
                new THREE.SphereGeometry(0.5, 16, 16),
                new THREE.MeshBasicMaterial({ color: 0xff0000 })
            );
            scene.add(this.mesh);
        }

        updatePosition() {
            const closestAgent = agents.reduce((closest, agent) => {
                const distance = this.position.distanceTo(agent.position);
                return distance < closest.distance ? { agent, distance } : closest;
            }, { agent: null, distance: Infinity });

            if (closestAgent.agent && closestAgent.distance < 20 * attentionScale) {
                const direction = new THREE.Vector3(
                    closestAgent.agent.position.x - this.position.x,
                    closestAgent.agent.position.y - this.position.y,
                    0
                ).normalize();
                this.position.add(direction.multiplyScalar(0.05));
            }

            this.mesh.position.copy(this.position);
        }
    }

    function addEnergySource() {
        const geometry = new THREE.SphereGeometry(0.3, 16, 16);
        const material = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const energySource = new THREE.Mesh(geometry, material);

        energySource.position.set(Math.random() * 80 - 40, Math.random() * 80 - 40, 0);
        scene.add(energySource);
        energySources.push({ mesh: energySource, position: energySource.position });
    }

    function addThreat() {
        const threat = new Threat();
        threats.push(threat);
    }

    function addAgent() {
        const agent = new QLearningAgent(agents.length, agentSpeed);
        agents.push(agent);
    }

    function animate() {
        requestAnimationFrame(animate);
        agents.forEach(agent => agent.updatePosition());
        threats.forEach(threat => threat.updatePosition());
        renderer.render(scene, camera);
    }

    initScene();
    for (let i = 0; i < 10; i++) addAgent();
    for (let i = 0; i < 5; i++) addThreat();
    for (let i = 0; i < 5; i++) addEnergySource();

    animate();

    document.getElementById("agentSpeed").addEventListener("input", e => agentSpeed = parseFloat(e.target.value));
    document.getElementById("attentionScale").addEventListener("input", e => attentionScale = parseFloat(e.target.value));
    document.getElementById("resetSimulation").addEventListener("click", () => location.reload());
</script>
</body>
</html>
